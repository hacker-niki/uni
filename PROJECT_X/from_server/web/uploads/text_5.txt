ТЕМА 10
10.1 Классификация шаблонов программных проектов
При реализации проектов по разработке программных систем и
моделированию бизнес-процессов встречаются ситуации, когда решение
проблем в различных проектах имеют сходные структурные черты. Попытки
выявить похожие схемы или структуры в рамках объектно-ориентированного
анализа и проектирования привели к появлению понятия шаблона (паттерна),
которое из абстрактной категории превратилось в непременный атрибут
современных CASE-средств.
Паттерны различаются степенью детализации и уровнем абстракции.
Используется следующая общая классификация паттернов по категориям их
применения:
 Архитектурные паттерны;
 Паттерны проектирования;
 Паттерны анализа;
 Паттерны тестирования;
 Паттерны реализации.
Архитектурные паттерны (Architectural patterns) – множество
предварительно определенных подсистем со спецификацией их
ответственности, правил и базовых принципов установления отношений
между ними.
Архитектурные паттерны предназначены для спецификации
фундаментальных схем структуризации программных систем. Наиболее
известными паттернами этой категории являются паттерны GRASP (General
Responsibility Assignment Software Pattern). Эти паттерны относятся к уровню
системы и подсистем, но не к уровню классов. Как правило, формулируются
в обобщенной форме, используют обычную терминологию и не зависят от
области приложения.
Паттерны проектирования (Design patterns) – специальные схемы для
уточнения структуры подсистем или компонентов программной системы и
отношений между ними. Паттерны проектирования описывают общую
структуру взаимодействия элементов программной системы, которые
реализуют исходную проблему проектирования в конкретном контексте.
Наиболее известными паттернами этой категории являются паттерны GoF
(Gang of Four), названные в честь Э. Гаммы, Р. Хелма, Р. Джонсона и Дж.
Влиссидеса, которые систематизировали их и представили общее описание.
Паттерны GoF включают в себя 23 паттерна. Они не зависят от языка
реализации, но их реализация зависит от области приложения.
Паттерны анализа (Analysis patterns) – специальные схемы для
представления общей организации процесса моделирования. Паттерны
анализа относятся к одной или нескольким предметным областям и
описываются в терминах предметной области. Наиболее известными
паттернами этой группы являются паттерны бизнес-моделирования ARIS
(Architecture of Integrated Information Systems), которые характеризуют
абстрактный уровень представления бизнес-процессов. В дальнейшем
паттерны анализа конкретизируются в типовых моделях с целью выполнения
аналитических оценок или имитационного моделирования бизнес-процессов.
Паттерны тестирования (Test patterns) – специальные схемы для
представления общей организации процесса тестирования программных
систем. К этой категории паттернов относятся такие паттерны, как
тестирование черного ящика, белого ящика, отдельных классов, системы.
Паттерны этой категории систематизировал и описал М. Гранд. Некоторые
из них реализованы в инструментальных средствах, наиболее известными из
которых является IBM Test Studio. В связи с этим паттерны тестирования
иногда называют стратегиями или схемами тестирования.
Паттерны реализации (Implementation patterns) – совокупность
компонентов и других элементов реализации, используемых в структуре
модели при написании программного кода. Эта категория паттернов делится
на следующие подкатегории: паттерны организации программного кода,
паттерны оптимизации программного кода, паттерны устойчивости кода,
паттерны разработки графического интерфейса пользователя и др. Паттерны
этой категории описаны в работах М. Гранда, К. Бека, Дж. Тидвелла и др.
Некоторые из них реализованы в популярных интегрированных средах
программирования в форме шаблонов создаваемых проектов. В этом случае
выбор шаблона программного приложения позволяет получить некоторую
заготовку программного кода.
10.2 Паттерны проектирования в нотации языка UML
В сфере разработки программных систем наибольшее применение
получили паттерны проектирования GoF, некоторые из них реализованы в
популярных средах программирования. При этом паттерны проектирования
могут быть представлены в наглядной форме с помощью рассмотренных
обозначений языка UML. Паттерн проектирования в контексте языка UML
представляет собой параметризованную кооперацию вместе с описанием
базовых принципов ее использования.
При изображении паттерна используется обозначение
параметризованной кооперации языка UML ( рис. 10.1), которая
обозначается пунктирным эллипсом. В правый верхний угол эллипса встроен
пунктирный прямоугольник, в котором перечислены параметры кооперации,
которая представляет тот или иной паттерн.
Рисунок 10.1 – Изображение паттерна в форме параметризованной
кооперации
В последующем параметры паттерна могут быть заменены различными
классами, чтобы получить реализацию паттерна в рамках конкретной
кооперации. Эти параметры специфицируют используемые классы в форме
ролей классов в рассматриваемой подсистеме. При связывании или
реализации паттерна любая линия помечается именем параметра паттерна,
которое является именем роли соответствующей ассоциации. В дополнение к
диаграммам кооперации особенности реализации отдельных паттернов
представляются с помощью диаграмм последовательности.
Паттерны проектирования позволяют решать различные задачи, с
которыми постоянно сталкиваются проектировщики объектно-
ориентированных приложений. Ниже представлен полный список паттернов
проектирования GoF и краткое описание назначения каждого из них
В качестве примеров рассматриваются два паттерна проектирования,
которые нашли наибольшее применение при проектировании программных
систем: паттерны Фасад и Наблюдатель.
10.3 Паттерн Фасад и его обозначение в нотации языка UML
Паттерн Фасад предназначен для замены нескольких разнотипных
интерфейсов доступа к определенной подсистеме некоторым
унифицированным интерфейсом, что существенно упрощает использование
рассматриваемой подсистемы. Общее представление паттерна
проектирования Фасад может быть изображено с помощью следующей
диаграммы параметризованной кооперации ( рис. 10.2).
Рисунок 10.2 – Общее представление паттерна проектирования Фасад
Изображенная параметризованная кооперация содержит 4 параметра:
класс Facade (Фасад), интерфейс IFacade, интерфейсы IConcreteClass и
конкретные классы ConcreteClass, в которых реализованы интерфейсы
IConcreteClass. Пунктирная линия со стрелкой в форме треугольника служит
для обозначения отношения реализации (не путать с отношением обобщения
классов).
При решении конкретных задач проектирования данный паттерн может
быть конкретизирован. В этом случае вместо параметров изображенной
кооперации должны быть указаны классы, предназначенные для решения
отдельных задач.
Ниже приведен пример, который иллюстрирует использование паттерна
Фасад для выполнения операций по заданию и считыванию адресов из базы
данных сотрудников. Фрагмент соответствующей диаграммы классов
содержит 2 класса: Адрес и интерфейс к операциям этого класса IАдрес ( рис.
10.3). При задании адреса нового сотрудника необходимо обратиться к этому
интерфейсу и последовательно выполнить операции: задатьУлицу(),
задатьДом(), задатьКорпус(), задатьКвартиру(), используя в качестве
аргумента идентификационный номер нового сотрудника. Для получения
информации об адресе сотрудника, необходимо также обратиться к этому
интерфейсу и последовательно выполнить операции: прочитатьУлицу(),
прочитатьДом(), прочитатьКорпус(), прочитатьКвартиру(), используя в
качестве аргумента идентификационный номер интересующего сотрудника.
Очевидно, отслеживать при каждом обращении правильность
выполнения этих последовательностей операций неудобно. С этой целью к
данному фрагменту следует добавить еще один интерфейс, реализацию
паттерна Фасад для рассматриваемой ситуации. Соответствующий фрагмент
модифицированной диаграммы классов будет содержать 4 класса ( рис. 10.4),
изображенные таким образом, чтобы иллюстрировать реализацию
параметризованной кооперации.
Рисунок 10.3 – Фрагмент диаграммы классов до применения паттерна Фасад
Рисунок 10.4 – Конкретная реализация паттерна проектирования Фасад
При задании адреса нового сотрудника в этом случае достаточно
обратиться к интерфейсу IФасад и выполнить единственную операцию:
задатьАдрес(), используя в качестве аргумента идентификационный номер
нового сотрудника. Для получения информации об адресе сотрудника также
достаточно обратиться к этому интерфейсу и выполнить единственную
операцию: прочитатьАдрес(), используя в качестве аргумента
идентификационный номер интересующего сотрудника. Реализацию данных
операций следует предусмотреть в классе Фасад. Взаимодействие объектов
этих классов может быть представлено с помощью диаграммы
последовательности ( рис. 10.5).
Аналогичная диаграмма последовательности может быть построена для
выполнения операции по чтению адреса. Использование паттерна Фасад
обеспечивает для клиента не только простоту доступа к информации об
адресах, но и независимость представления объектов класса Адрес от
запросов клиентов. Это обстоятельство особенно актуально при изменении
формата представления информации или смене соответствующей базы
данных. В этом случае потребуется внести изменения только в реализацию
операций класса Фасад.
Рисунок 10.5 – Диаграмма последовательности для
выполнения операции задания адреса
10.4 Паттерн Наблюдатель и его обозначение в нотации языка UML
Паттерн Наблюдатель предназначен для контроля изменений состояния
объекта и передачи информации об изменении этого состояния множеству
клиентов. В общем случае паттерн Наблюдатель также может быть
изображен в виде параметризованной кооперации ( рис. 10.6).
Рисунок 10.6 – Общее представление паттерна проектирования Наблюдатель
Изображенная параметризованная кооперация содержит 4 параметра:
абстрактный класс Subject (Субъект), класс ConcreteSubject (Конкретный
Субъект), абстрактный класс Observer (Наблюдатель) и класс
ConcreteObserver (Конкретный Наблюдатель). Пунктирная линия со стрелкой
в форме треугольника служит для обозначения отношения обобщения
классов.
При решении конкретных задач проектирования данный паттерн также
может быть конкретизирован. В этом случае вместо параметров
изображенной кооперации должны быть указаны классы, предназначенные
для решения отдельных задач.
Рассмотрим пример, который иллюстрирует использование паттерна
Наблюдатель для отслеживания изменений в таблице БД и отражении этих
изменений на диаграммах. Для определенности можно использовать таблицу
БД и две диаграммы – круговую и столбиковую. Фрагмент соответствующей
диаграммы классов содержит 5 классов ( рис. 10.7).
Рисунок 10.7 – Реализация паттерна проектирования Наблюдатель
В этом случае за субъектом Таблицей MS Access может "следить"
произвольное число наблюдателей, причем их добавление или удаление не
влияет на представление информации в БД. Класс Таблица MS Access
реализует операции по отслеживанию изменений в соответствующей
таблице, и при их наличии сразу информирует абстрактного наблюдателя.
Тот в свою очередь вызывает операции по перерисовке соответствующих
диаграмм у конкретных наблюдателей, в качестве которых выступают
классы Круговая Диаграмма и Столбиковая Диаграмма.
Использование паттерна Наблюдатель не только упрощает
взаимодействие между объектами соответствующих классов, но и позволяет
вносить изменения в реализацию операций классов субъекта и наблюдателей
независимо друг от друга. При этом процесс добавления или удаления
наблюдателей никак не влияет на особенности реализации класса субъекта.
В заключении следует отметить, что язык UML представляет собой
нотацию для визуального моделирования программных систем и бизнес-
процессов. В то же время описание языка UML не содержит сведений
относительно того, каким образом и в какой последовательности следует
разрабатывать канонические диаграммы при выполнении конкретных
проектов. Соответствующая информация относится к области методологии
проектирования программных систем.
ТЕМА 13
План лекции
1. Создание модели предметной области.
2. Создание модели анализа.
3. Проектирование программной системы модульной структуры.
13.1 Создание моделей предметной области и анализа
средствами диаграммы классов
Создание модели предметной области начинается уже на этапе
определения требований (диаграмма Use Case) и завершается на этапе анализа.
Для ее построения используется диаграмма классов, на которой отображены
не классы разрабатываемой системы, а понятия предметной области и связи
между ними. При этом достаточно использовать всего один тип связей:
Directed Association (направленная ассоциация).
Следует помнить, что найденные понятия – это только кандидаты на
создание классов, поэтому модель предметной области нельзя напрямую
преобразовывать в диаграмму классов. В дальнейшем, на этапе анализа и
проектирования у выявленных объектов предметной области находят общие
черты, свойства, иерархию, которая позволяет создавать непротиворечивую
модель проектирования и реализации. На рис. 13.1 приведена модель
предметно области виртуального книжного магазина.
Модель предметной области отражает не все понятия, которые могут
понадобиться для создания приложения. Для создания программной системы
определяется то подмножество объектов, которое необходимо для реализации
прецедентов на текущей итерации. Возможно, впоследствии их количество
будет изменено.
Для модели книжного магазины были определены следующие понятия
и связи между ними. Покупатель, просматривая Каталог, складывает Книги,
которые хранятся в этом Каталоге в Корзину покупателя. Для поиска и
изменения порядка представления книг в каталоге может использоваться
Автор, написавший книгу и Издательство, которое ее выпустило в свет, а
также дополнительные атрибуты, присущие книгам – дата выпуска и цена.
Используя информацию о книгах в Корзине покупателя, создается Заказ на
покупку, статус которого может быть просмотрен и изменен
Администратором.
Модель анализа, как и модель предметной области, необходимо для
создания надежной и устойчивой архитектуры, а также понимания
требований, предъявляемых к системе. Фактически модель анализа – это набор
диаграмм, показывающих, как планируется реализовать в системе каждый
прецедент. И хотя на этой модели уже присутствуют классы и связи между
ними, они еще далеки до окончательного варианта системы.
Рис. 13.1 – Модель предметной области виртуального магазина
Модель анализа должна создаваться независимой от программных
средств, которыми она будет реализовываться и должна подходить для разных
проектов. Позже, когда на ее основе будет строиться проект классов системы,
потребуется учитывать языковые ограничения, накладываемые реализацией
конкретного проекта.
Для создания модели используются три стереотипа классов, которые
определяют их назначение: граничный класс (boundary), сущность (entity),
управление (control).
Стереотип граничный класс показывает, что класс предназначен для
взаимодействия с внешними актерами и стоит на границе системы, поэтому и
называется граничным. Такой класс, получая сообщение от внешнего актера,
транслирует их внутрь системы, генерируя и передавая соответствующие
сообщения другим классам.
Классы сущности используются для моделирования классов, которые
отвечают за хранение определенной информации. Эти классы реализуют
возможности по получению, изменению и сохранению информации в базе
данных. Классы сущности обычно не отражаются ни на одной диаграмме
прецедентов, но требуются для выполнения внутреннего хранения данных.
Классы управления используются для координации работы других
классов приложения. Поведение этих классов обычно реализует один или
несколько прецедентов, показанных на диаграммах моделирования. КлассыПокупатель Каталог
Корзина
Заказ
+ Дата : int
+ Статус : int
Книги
+ Дата_выхода : int
Издательство
Автор
Администратор
Просматривает
Складывает книги
Написал
Находятся
Издает
Меняет статус
Делает
Хранятся
Создается
Оформляется
управления реализуют поведение системы при помощи потоков управления.
Они являются промежуточными звеньями между граничными классами и
классами сущностями.
На рис. 13.2 приведена модель анализа книжного магазина.
Рис. 13.2 Модель анализа книжного магазина
На модели анализа книжного магазина роль граничных классов
выполняют окна, с которыми взаимодействуют пользователи. Покупатель
вводит регистрационную информацию, граничный класс ее принимает и
передает дальше для обработки. Покупатель добавляет товар в корзину,
другой граничный класс отправляет соответствующее сообщение в систему,
где оно обрабатывается классом-контроллером.
Для виртуального магазина классы управления – это классы обработки
заказов или управления регистрацией.
Классы сущностей были созданы в процессе разработки модели
предметной области, поэтому их необходимо перенести оттуда в модель
анализа.
Проектирование программной системы с помощью диаграммы классов
На этапе проектирования диаграмма классов используется для
разработки подсистем и иерархии классов. Одна или несколько диаграммПокупатель
Регистр
ация
Каталог
Корзина
Заказ
Управ
регистр
Пользователь
Управ
ление
опове
щ
Управ.
каталог
ом
Управ.
корзиной
Управ.
заказом
Издат-во
View
Корзина
Заказ
Автор
Книга
Запрос и сохранение
Оповещ. админа
Показ. каталог
Добавить
Передача заказа
Получение списка товаров
Сохранение
Сохранение/удаление
классов описывают классы верхнего уровня. При включении на диаграмму
пакетов в модель добавляются диаграммы классов, описывающие содержимое
пакетов. Пакеты обычно используют для группирования классов по
подсистемам. Кроме классов, в подсистемы могут включаться реализации
вариантов использования, интерфейсы и другие подсистемы. Разделение на
подсистемы значительно упрощает параллельную разработку,
конфигурирование и инсталляцию конечного продукта. Создание подсистем
позволяет проще устанавливать различные категории доступа к информации
для пользователей, а также отделить алгоритмы для организации связи с
внешними продуктами.
При выполнении разделения системы на подсистемы рекомендуется
придерживаться следующих правил:
1. Находят части системы, чье поведение может быть необязательным, и
выделяют их в подсистему. Если какие-то возможности системы являются
факультативными, то классы, реализующие эти возможности, помещают в
отдельную подсистему.
2. Если интерфейс пользователя представляется классами, которые
планируется изменять независимо от остальной системы, то возможно
создание подсистем по принципу горизонтального разделения, т.е. в одну
подсистему собираются все граничные классы, а в другую – все классы
сущности. Также возможна вертикальная группировка граничных классов и
связанных с ними классов сущностей.
3. Разделение на подсистемы может осуществляться для реализации
функций взаимодействия с конкретными актерами, например, можно
выделить подсистему взаимодействия с внешними устройствами или
унаследованными системами.
4. Сильно связанные классы организуют в подсистемы. Если какой-либо
из классов не укладывается в подсистему, его делят на части,
взаимодействующие между собой через интерфейс.
5. Если необходимо создать несколько уровней сервиса, которые
реализуются различными интерфейсами, то необходимо организовать каждый
уровень сервиса в отдельную подсистему.
6. Если необходимо реализовать выполнение системы для различных
типов технических средств или операционных систем, то необходимо
выделить функции, зависящие от конкретных аппаратно-программных
средств в отдельные подсистемы.
Для разрабатываемого виртуального книжного магазина можно
выделить следующие подсистемы: Управление регистрацией, Управление
каталогами, Управление заказами, Управление сервисными функциями.
Подсистем Управление регистрацией должна включать в себя все
классы, которые относятся к регистрации, вместе с сущностями и граничными
классами. Сам процесс регистрации довольно обособлен и мало связан с
другими процессами, поддерживаемыми системой, поэтому разумно
поместить его в отдельную подсистему.
Подсистема Управление каталогом будет включать в себя все классы,
позволяющие пользователю взаимодействовать с каталогом книжного
магазина. Кроме того, при дальнейшем расширении системы сюда же попадут
классы, осуществляющие ввод и редактирование информации в каталоге.
Подсистема Управление заказами будет содержать классы,
реализующие функции работы с заказами как покупателя, так и
администратора. Процесс управления заказами сложнее, чем функционал
предыдущей подсистемы, поэтому эти функции также логично выделить в
отдельную подсистему.
Подсистема Управление сервисными функциями содержит классы,
которые отвечают за рассылку почтовых сообщений пользователям и
администраторам. В будущем набор функций этой подсистемы может
расширяться.
На рис. 13.3 показан проект подсистем книжного магазина.
Таким образом, проект состоит из четырех подсистем, связанных с
помощью Dependency и содержащих интерфейсы.
Рис. 13.3 – Проект книжного магазина
При разработке приложения .NET интерфейс обозначает полноценные
объекты, которые проектируются наравне с классами системы. В .NET
интерфейс – это элемент, включаемый в классы, которые должны его
реализовывать. Такой подход позволяет разрабатывать интерфейсы отдельно,
а затем включать их в нужные классы. На структуру интерфейса
накладываются ограничения. В его состав входят только абстрактные члены,
в нем могут быть определены события, методы, свойства, но он не может
содержать конструкторов, деструкторов и констант.
Интерфейс посылки сообщения означает, что в подсистеме Управление
сервисными функциями должен быть класс, который реализует этот
интерфейс, а установка связей с другими подсистемами указывает на то, что и
в них должны быть классы, которые обращаются к этому интерфейсу.
Фактически проектирование подсистем начинается с разработки их
интерфейсов, а затем создаются классы, которые их реализуют.Подсистема "Управление
регистрацией" Подсистема "Управление
каталогом
Подсистема "Управление
сервисными функциями"
Подсистема "Управление
заказами"
Активизировать
Подтвердить
Послать
сообщение
Сделать заказ
Интерфейс Активизировать определяет возможность подсистемы
Управление регистрацией передавать управление подсистеме Управление
каталогом.
Интерфейс Сделать заказ определяет возможность подсистемы
Управление каталогом передавать заказ на обработку подсистеме Управление
заказами.
Интерфейс Подтвердить позволяет подтверждать заказ, например, из
подсистемы Управление каталогом.
После того, как спроектирована архитектура системы и определены
интерфейсы между ее подсистемами, можно переходить к детальной
разработке классов, готовя их к кодогенерации.
Рассмотрим проектирование граничных классов виртуального книжного
магазина. Первым граничным классом является класс CRegister. Это первое
окно, с которым взаимодействует пользователь, и которое должно
переключать приложение в режим просмотра каталога или в режим
регистрации нового пользователя. Для .NET приложений структура классов
практически для всех ASP страниц, использующих граничные классы, будет
схожа, как это показано на рис. 13.4. Каждая страница сервера наследуется от
определенного класса и включает в себя форму ввода.
Рис. 13.4 – Структура связей класса CRegister
Для работы системы нужен еще один граничный класс, который бы
принимал данные пользователя и передавал бы их в систему. Это класс
CUserData. Структура его связей приведена на рис. 13.5 Форма UserData будет
принимать имя, адрес электронной почты и пароль будущего покупателя,
после чего передавать их дальше.WebForm1
# TextBox1 : System.Web.UI.WebControls.TextBox
# TextBox2 : System.Web.UI.WebControls.TextBox
# Button1 : System.Web.UI.WebControls.Button
# Button2 : System.Web.UI.WebControls.Button
# Label2 : System.Web.UI.WebControls.Label
# Label3 : System.Web.UI.WebControls.Label
- Page_Load ( )
# OnInit ( )
- InitializeComponent ( )
Client Page
Server Page
CRegister
- Page_Init ( )
# OnInit ( )
- InicializeComp ( )
- Enter_Click ( )
- Register_Click ( )- _WebForm1
*
- _Class1
0..1
Рис. 13.5 – Структура связей класса CUserData
Рассмотрим работу нескольких классов-сущностей. Класс CAccount
должен сохранять информацию о пользователе в базе данных. Другие
сущности также будут обращаться к серверу сети. Чтобы не устанавливать
параметры соединения в каждом классе, удобнее создать класс, который бы
отвечал за подключение к базе данных. Пусть это будет класс CServer,
который должен предоставлять доступ к методам библиотечного класса
SqlConnection при использовании MS SQL Server. Если вынести обработку
соединения в отдельный класс, то в дальнейшем, когда потребуется
организовать работу с другими типами СУБД, необходимо будет лишь внести
изменения в методы CServer.
Логично будет разделить работу с сервером электронной почты и
определение структуры сообщения оповещения. Для работы с почтой
создадим класс CMail, который будет предоставлять интерфейс к методам
библиотечных классов SmtpMail и MailMessage.
За формирование самого почтового отправления отвечает класс CNotify.
Структура связей классов-сущностей приведена на рис. 13.6.WebForm1 UserData
# TextBox1 : System.Web.UI.WebControls.TextBox
# TextBox2 : System.Web.UI.WebControls.TextBox
# Button1 : System.Web.UI.WebControls.Button
# Button2 : System.Web.UI.WebControls.Button
# Label2 : System.Web.UI.WebControls.Label
# Label3 : System.Web.UI.WebControls.Label
- Page_Load ( )
# OnInit ( )
- InitializeComponent ( )
Client Page User Data
Server Page UserData
CUserData
- Page_Init ( )
# OnInit ( )
- InicializeComp ( )
- Button_Click ( )
- _WebForm1
*
- _Class1
0..1
Рис. 13.6 – Структура и связи классов-сущностейCServer
+ Open ( )
+ Close ( )
+ Cserver ( )
+ Exute ( )
CAccount
+ Name : string
+ Email : String
+ Password : string
+ User : String
+ Save ( )
+ Update ( )
+ Caccount ( )
Cmail
+ Cmail ( )
+ Send ( )
CNotify
+ Cnotify ( )
+ CAddUser ( )
- _CNotify
0..1
- _Cmail 0..1
