Виртуальная память
В первых компьютерах память была очень мала по объему и к тому же дорого
стоила. IBM-650, ведущий компьютер того времени (конец 50-х годов), содер-
жал всего 2000 слов памяти. Один из первых 60 компиляторов ALGOL был
написан для компьютера с объемом памяти всего 1024 слова. Древняя система
с разделением времени прекрасно работала на компьютере PDP-1, общий объем
памяти которого составлял всего 4096 18-разрядных слов для операционной си-
стемы и пользовательских программ. В те времена программисты тратили очень
много времени, пытаясь вместить свои программы в крошечную память. Часто
приходилось использовать более медленный алгоритм только потому, что более
быстрый не удавалось разместить в памяти компьютера.
Традиционным решением проблемы было использование вспомогатель-
ной памяти (например, диска). Программист делил программу на несколько
частей, так называемых оверлеев, каждый из которых помещался в память.
Чтобы выполнить программу, сначала нужно было считать и запустить пер-
вый оверлей. Когда он завершался, считывался и запускался второй оверлей
и т. д. Программист отвечал за разбиение программы на оверлеи и решал,
в каком месте вспомогательной памяти должен храниться каждый оверлей,
контролировал передачу оверлеев между основной и вспомогательной памятью
и вообще управлял всем этим процессом без какой-либо помощи со стороны
компьютера.
Хотя эта технология широко использовалась на протяжении многих лет, она
требовала длительной кропотливой работы, связанной с управлением оверлеями.
В 1961 году группа исследователей из Манчестера (Англия) предложила метод
автоматической реализации подгрузки кода, при котором программист мог
вообще не знать об этом процессе [Fotheringham, 1961]. Этот метод, в основе
которого, как сейчас говорят, лежит использование виртуальной памяти, имел
очевидное преимущество, поскольку освобождал программиста от массы рутин-
ной работы. Впервые этот метод был применен в ряде компьютеров, выпущенных
в 60-е годы — в основном для исследовательских проектов в области компью-
терных технологий. К началу 70-х годов виртуальная память была реализованаВиртуальная память
477
в большинстве компьютеров. В настоящее время даже компьютеры на одной
микросхеме, в том числе Core i7 и OMAP4430, содержат очень сложные системы
виртуальной памяти. Мы рассмотрим их далее в этой главе.
Страничная организация памяти
Идею о разделении понятий адресного пространства и адресов памяти выдви-
нула группа ученых из Манчестера. Рассмотрим в качестве примера типичный
компьютер того времени с 16-разрядным полем адреса в командах и 4096 сло-
вами памяти. Программа, работающая на таком компьютере, могла обращаться
к 65 536 словам памяти (поскольку адреса были 16-разрядными, а 216 = 65 536).
Обратите внимание, что число адресуемых слов зависит только от числа битов
адреса и никак не связано с числом реально доступных слов в памяти. Адресное
пространство такого компьютера состоит из чисел 0, 1, 2, ..., 65 535, так как это —
набор всех возможных адресов. Однако в действительности компьютер мог иметь
гораздо меньше слов в памяти.
До изобретения виртуальной памяти приходилось проводить жесткое разли-
чие между адресами, меньшими 4096, и адресами равными или большими 4096.
Эти две части рассматривались как полезное адресное пространство и бесполез-
ное адресное пространство соответственно (адреса выше 4095 были бесполез-
ными, поскольку они не соответствовали реальным адресам памяти). Никакого
различия между адресным пространством и адресами памяти не проводилось,
поскольку между ними подразумевалось взаимно-однозначное соответствие.
Идея разделения понятий адресного пространства и адресов памяти состо-
ит в следующем. В любой момент времени можно получить прямой доступ
к 4096 словам памяти, но это не значит, что они непременно должны соответство-
вать адресам памяти от 0 до 4095. Например, мы могли бы сообщить компьютеру,
что при обращении к адресу 4096 нужно использоваться слово из памяти с адресом
0, при обращении к адресу 4097 — слово из памяти с адресом 1, при обращении
к адресу 8191 — слово из памяти с адресом 4095 и т. д. Другими словами, адресное
пространство отображается на действительные адреса памяти (рис. 6.2).
Рис. 6.2. Виртуальные адреса памяти с 4096 по 8191 отображаются
на адреса основной памяти с 0 по 4095
Согласно этой схеме отображения адресов адресного пространства на факти-
ческие ячейки памяти, в машине с объемом памяти 4 Кбайт (без виртуальной
памяти) между адресами от 0 до 4095 и словами памяти числом 4096 существует
прямое соответствие. Возникает интересный вопрос: а что произойдет, если про-478
Глава 6. Уровень операционной системы
грамма совершит переход к одному из адресов в диапазоне от 8192 по 12 287?
В машине без виртуальной памяти произойдет ошибка, на экран будет выведено
сообщение об обращении к несуществующему адресу памяти, и выполнение про-
граммы прервется. На машине с виртуальной памятью произойдет следующее:
1. Содержимое основной памяти будет сохранено на диске.
2. Слова с 8192 по 12 287 будут сохранены на диске.
3. Слова с 8192 до 12 287 будут загружены в основную память.
4. Отображение адресов изменится: адреса с 8192 по 12 287 будут соответство-
вать ячейкам памяти с 0 по 4095.
5. Выполнение программы продолжится, как будто ничего необычного не слу-
чилось.
Такая технология автоматического наложения называется страничной ор-
ганизацией памяти, а фрагменты программы, которые считываются с диска, —
страницами.
Есть и другой, более сложный способ отображения адресов адресного про-
странства программы на реальные адреса памяти. Адреса, к которым программа
может обращаться, мы будем называть виртуальным адресным пространством,
а реальные адреса памяти, реализованные аппаратно, — физическим адресным
пространством. В карте памяти, или таблице страниц, хранится информация
о соответствии между виртуальными и физическими адресами. Предполагается,
что на диске достаточно места для хранения полного виртуального адресного
пространства (или, по крайней мере, той его части, которая используется в дан-
ный момент).
Программы пишутся так, как будто в основной памяти хватает места для
размещения всего виртуального адресного пространства, даже если это не соот-
ветствует действительности. Программы могут загружать слова из виртуального
адресного пространства или записывать слова в виртуальное адресное про-
странство, несмотря на то что на самом деле физической памяти для этого не
хватает. Программист может писать программы, даже не зная о существовании
виртуальной памяти. Просто с его точки зрения все выглядит так, словно объем
памяти данного компьютера достаточно велик.
Позднее мы сравним страничную организацию памяти с процессом сегмен-
тации, при котором программисту требуется знать о существовании сегментов.
Еще раз подчеркнем, что страничная организация памяти создает иллюзию
линейной основной памяти такого же размера, как адресное пространство про-
граммы. В действительности основная память может быть меньше (или больше),
чем виртуальное адресное пространство. То, что память большого размера просто
моделируется путем страничной организации памяти, нельзя определить по про-
грамме (только за счет тестирования). При обращении к любому адресу всегда
появляются требуемые данные или нужная команда. Поскольку программист
может писать программы, ничего не зная о страничной организации памяти, этот
механизм называют прозрачным.
Ситуация, когда программист использует какой-либо виртуальный механизм
и даже не знает, как он работает, не нова. В архитектуры команд, например, часто
включается команда MUL (умножение), даже если аппаратно умножение не под-
держивается. Иллюзия того, что машина может перемножать числа, создаетсяВиртуальная память
479
микропрограммой. Точно так же операционная система может создавать иллю-
зию, что все виртуальные адреса поддерживаются реальной памятью, даже если
это неправда. Только разработчикам и исследователям операционных систем
нужно знать, как строится такая иллюзия.
