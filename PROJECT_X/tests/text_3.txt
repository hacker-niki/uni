Тема: «Функции Python. Файлы. Модули. Пакеты»
Функция – это средство, позволяющее группировать наборы
инструкций так, что в программе они могут запускаться неоднократно.
Функции обеспечивают многократное использование программного
кода и уменьшающие его избыточность.
Основные концепции, составляющие основу функций в языке Python:
• def – это исполняемый программный код. Функции в языке Python
создаются с помощью новой инструкции def (создает объект и присваивает
ему имя).
• Выражение lambda создает объект и возвращает его в виде результата.
• return передает объект результата вызывающей программе.
• yield передает объект результата вызывающей программе и
запоминает, где был произведен возврат.
• аргументы передаются посредством присваивания (в виде ссылок на
объекты).
Основные концепции, составляющие основу функций в языке Python:
• global объявляет глобальные переменные для модуля, без
присваивания им значений.
• nonlocal объявляет переменные, находящиеся в области видимости
объемлющей функции, без присваивания им значений.
• Аргументы получают свои значения (ссылки на объекты) в результате
выполнения операции присваивания.
• Аргументы, возвращаемые значения и переменные не объявляются.
Инструкция def
def <name>(arg1, arg2,... argN): # возвращает объект None
<statements>
def <name>(arg1, arg2,... argN):
...
return <value>
def <name>(arg1, arg2,... argN):
...
yield <value>
if test:
def func(): # Определяет функцию таким способом
...
else:
def func(): # Или таким способом
...
...
func() # Вызов выбранной версии
othername = func # Связывание объекта функции с
именем
othername() # Вызов функции
def func():... # Создает объект функции
func() # Вызывает объект
func.attr=value # Присоединяет атрибут к объекту
Функции имеют две стороны:
• определение (инструкция def, которая создает функцию)
• вызов (выражение, которое предписывает интерпретатору выполнить
тело функции).
Определение
def times(x, y): # Создать функцию и связать ее с
именем
return x * y # Тело, выполняемое при вызове
функции
Вызов
>>> times(2, 4) # Аргументы в круглых скобках
>>> x = times(3.14, 4) # Сохранить объект
результата
>>> x
12.56
>>>times(‘word’, 2) # Функции не имеют типа
‘wordword’
Полиморфизм в языке Python
def times(x, y):
return x * y
Полиморфизм – термин, который означает, что смысл операции
зависит от типов обрабатываемых объектов.
Полиморфизм в языке Python
def times(x, y):
return x * y
Полиморфизм – термин, который означает, что смысл операции
зависит от типов обрабатываемых объектов.
Пример
def intersect(seq1, seq2):
res= [] # Изначально пустой результат
for x in seq1: # Обход последовательности seq1
if x in seq2: # Общий элемент?
res.append(x) # Добавить в конец
return res
>>> s1 = “SPAM
>>> s2 = “SCAM”
>>>intersect(s1, s2) # Строки
[‘S’, ‘A’, ‘M’]
>>> [x for x in s1 if x in s2] # генератор списков
[‘S’, ‘A’, ‘M’]
>>>x = intersect([1, 2, 3], (1, 4)) # Смешивание типов
>>>x # Объект с результатом
[1]
Локальные переменные
def intersect(seq1, seq2):
res= [] # Изначально пустой результат
for x in seq1: # Обход последовательности seq1
if x in seq2: # Общий элемент?
res.append(x) # Добавить в конец
return res
Почти все переменные в функции intersect являются локальными, так:
• Переменная res явно участвует в операции присваивания, поэтому она
– локальная переменная.
• Аргументы передаются через операцию присваивания, поэтому seq1
и seq2 тоже локальные переменные.
• Цикл for присваивает элементы переменной, поэтому имя x также
является локальным.
Области видимости в языке Python
• Имена, определяемые внутри инструкции def, видны только
программному коду внутри инструкции def. К этим именам нельзя обратиться
за пределами функции.
• Имена, определяемые внутри инструкции def, не вступают в конфликт
с именами, находящимися за пределами инструкции def, даже если и там и там
присутствуют одинаковые имена.
Области видимости в языке Python
• Если присваивание переменной выполняется внутри инструкции def,
переменная является локальной для этой функции.
• Если присваивание производится в пределах объемлющей
инструкции def, переменная является нелокальной для этой функции.
• Если присваивание производится за пределами всех инструкций def,
она является глобальной для всего файла.
X = 99
def func():
X = 88
Правила видимости имен
• Объемлющий модуль – это глобальная область видимости.
• Глобальная область видимости охватывает единственный файл. Не
надо заблуждаться насчет слова «глобальный» – имена на верхнем уровне
файла являются глобальными только для программного кода в этом файле.
• Каждый вызов функции создает новую локальную область
видимости. Всякий раз, когда вызывается функция, создается новая локальная
область видимости – то есть пространство имен, в котором находятся имена,
определяемые внутри функции.
• Операция присваивания создает локальные имена, если они не были
объявлены глобальными или нелокальными. global , nonlocal
• Все остальные имена являются локальными в области видимости
объемлющей функции, глобальными или встроенными.
L = []
L.append(X)
L =X
Разрешение имен: правило LEGB
Для инструкции def:
• Поиск имен ведется самое большее в четырех областях видимости:
локальной, затем в объемлющей функции (если таковая имеется), затем в
глобальной и, наконец, во встроенной.
• По умолчанию операция присваивания создает локальные имена.
• Объявления global и nonlocal отображают имена на область видимости
вмещающего модуля и функции соответственно.
Когда внутри функции выполняется обращение к неизвестному имени,
интерпретатор пытается отыскать его в четырех областях видимости:
• в локальной (local, L),
• затем в локальной области любой объемлющей инструкции def
(enclosing, E) или в выражении lambda,
• затем в глобальной (global, G)
• и, наконец, во встроенной (built-in, B).
Поиск завершается, как только будет найдено первое подходящее имя.
• Когда внутри функции выполняется операция присваивания,
интерпретатор всегда создает или изменяет имя в локальной области
видимости, если в этой функции оно не было объявлено глобальным или
нелокальным.
• Когда выполняется присваивание имени за пределами функции (то
есть на уровне модуля или в интерактивной оболочке), локальная область
видимости совпадает с глобальной – с пространством имен модуля.
Пример области видимости
# Глобальная область видимости
X = 99 # X и func определены в модуле: глобальная область
def func(Y): # Y и Z определены в функции: локальная область
# Локальная область видимости
Z=X+Y # X – глобальная переменная
return Z
func(1) # func в модуле: вернет число 100
Встроенная область видимости
>>>zip # Обычный способ
<class zip>
>>>import builtins # Более сложный способ
>>>builtins.zip
<class zip>
def hider():
open= ‘spam’ # Локальная переменная, переопределяет встроенное имя
...
open(‘data.txt’) # В этой области видимости файл не будет открыт!
X = 88 # Глобальная переменная X
def func():
X = 99 # Локальная переменная X: переопределяет глобальную
func()
print(X) # Выведет 88: значение не изменилось
Инструкция global
Инструкция global сообщает интерпретатору, что функция будет
изменять одно или более глобальных имен, то есть имен, которые находятся в
области видимости (в пространстве имен) вмещающего модуля.
Общая информация об инструкции global:
• Глобальные имена – это имена, которые определены на верхнем
уровне вмещающего модуля.
• Глобальные имена должны объявляться, только если им будут
присваиваться значения внутри функций.
• Обращаться к глобальным именам внутри функций можно и без
объявления их глобальными.
X = 88 # Глобальная переменная X
def func():
global X
X = 99 # Глобальная переменная X: за пределами инструкции def
func()
print(X) # Выведет 99
y,z= 1, 2 # Глобальные переменные в модуле
def all_global():
global x # Объявляется глобальной для присваивания
x=y+z # Объявлять y, z не требуется: применяется правило LEGB
Передача аргументов
• Аргументы передаются через автоматическое присваивание объектов
локальным переменным.
• Операция присваивания именам аргументов внутри функции не
оказывает влияния на вызывающую программу.
• Изменение внутри функции аргумента, который является
изменяемым объектом, может оказывать влияние на вызывающую программу.
Схема передачи аргументов:
• Неизменяемые объекты передаются «по значению».
• Изменяемые объекты передаются «по указателю».
Cледует запомнить – функции могут оказывать воздействие на
передаваемые им изменяемые объекты, такие как списки и словари. Это не
всегда является проблемой и часто может приносить пользу.
Модули
import
Позволяет клиентам (импортерам) получать модуль целиком.
from
Позволяет клиентам получать определенные имена из модуля.
imp.reload
Обеспечивает возможность повторной загрузки модуля без остановки
интерпретатора Python.
С точки зрения теории модули играют как минимум три роли:
• Повторное использование программного кода
• Разделение системы пространств имен
• Реализация служб или данных для совместного пользования.
Повсюду в сценариях на языке Python используется нотация
object.attribute – большинство объектов обладают атрибутами, доступ к
которым можно получить с помощью оператора «.»
Создание модуля
текстовый файл с расширением «.py» #module1.py
def printer(x): # Атрибут модуля
print(x)
if.py
import if
Инструкции import или from
Обе инструкции отыскивают, компилируют и запускают программный
код модуля, если он еще не был загружен.
#module1.py
def printer(x): # Атрибут модуля
print(x)
>>> import module1 # Загрузить модуль целиком
>>> module1.printer(‘Hello world!’) # Имя дополняется именем модуля
Hello world!
#module1.py
def printer(x): # Атрибут модуля
print(x)
>>>from module1 import printer # Копировать одну переменную
>>>printer(‘Hello world!’) # Имя не требует дополнения Hello world!
#module1.py
def printer(x): # Атрибут модуля
print(x)
>>> from module1 import * # Скопировать все переменные
>>> printer(‘Hello world!’)
Hello world!
Потенциальные проблемы инструкции from
• Инструкция from делает местоположение переменных менее явным и
очевидным (имя name несет меньше информации, чем module.name)
• Инструкция from способна повреждать пространства имен, по
крайней мере, в принципе – если использовать ее для импортирования
переменных, когда существуют одноименные переменные в имеющейся
области видимости, то эти переменные просто будут перезаписаны.
• С другой стороны, инструкция from скрывает в себе более серьезные
проблемы, когда используется в комбинации с функцией reload, так как
импортированные имена могут ссылаться на предыдущие версии объектов.
• Кроме того, инструкция в форме from module import * действительно
может повреждать пространства имен и затрудняет понимание имен, особенно
когда она применяется более чем к одному файлу
Совет: отдавать предпочтение инструкции import для простых модулей,
явно перечислять необходимые переменные в инструкциях from и не
использовать форму from * для импорта более чем одного файла в модуле.
Пакеты модулей
В программировании связанные модули принято объединять в пакеты.
Пакет представляет собой каталог с файлами-модулями. Кроме того, внутри
пакета могут быть вложенные каталоги, а уже в них – файлы.
Допустим, мы пишем пакет модулей для вычисления площадей и
периметров фигур. Пакет будет состоять из двух модулей. В одном будут
описаны классы двумерных фигур, в другом – трехмерных.
Каталог-пакет назовем geometry. Один модуль – planimetry.py, другой
– stereometry.py. Пакет следует разместить в одном из каталогов,
содержащихся в списке sys.path. Первым его элементом является домашний
каталог, обозначаемый как пустая строка. Таким образом, пакет проще
разместить в том же каталоге, где будет основной скрипт.
Если не планируется писать скрипт, а достаточно протестировать пакет
в интерактивном режиме, то в Linux будет проще разместить его в домашнем
каталоге.
Содержимое файла planimetry.py:
from math import pi, pow
class Rectangle:
def __init__(self, a, b):
self.w = a
self.h = b
def square(self):
return round(self.w * self.h, 2)
def perimeter(self):
return 2 * (self.w + self.h)
class Circle:
def __init__(self, radius):
self.r = radius
def square(self):
return round(pi * pow(self.r, 2), 2)
def length(self):
return round(2 * pi * self.r)
Код файла stereometry.py:
from math import pi, pow
class Cuboid:
def __init__(self, a, b, c):
self.length = a
self.width = b
self.height = c
self.__sq_sur = 2 * (a * b + a * c + b * c)
self.__volume = a * b * c
def S(self):
return round(self.__sq_sur, 2)
def V(self):
return round(self.__volume, 2)
class Ball:
def __init__(self, radius):
self.r = radius
def S(self):
s = 4 * pi * pow(self.r, 2)
return round(s, 2)
def V(self):
v = (4 / 3) * pi * pow(self.r, 3)
return round(v, 2)
Также в каталоге пакета должен быть файл __init__.py, даже если этот
файл будет пустым. Его наличие позволяет интерпретатору понять, что перед
ним пакет, а не просто каталог. Файл __init__.py может быть не пустым, а
содержать переменную, в которой перечислены модули, которые будут
импортироваться командой from имя_пакета import *, а также какой-либо
инициирующий код, например, подключение к базе данных.
Теперь попробуем импортировать модули пакета:
>>> import geometry.planimetry as pl
>>> import geometry.stereometry as st
>>> a = pl.Rectangle(3, 4)
>>> b = st.Ball(5)
>>> a.square()
12
>>> b.V()
523.6
Если сделать импорт только пакета, то мы не сможем обращаться к
модулям:
pl@pl-desk:~$ python3
Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits"
or "license" for more information.
>>> import geometry
>>> b = geometry.stereometry.Ball(5)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: module 'geometry'
has no attribute 'stereometry'
Тогда возникает вопрос: в чем выгода пакетов, если все равно
приходится импортировать модули индивидуально? Основной смысл
заключается в структурировании пространств имен. Представьте, что есть
разные пакеты, содержащие одноименные модули и классы. В таком случае
точечная нотация через имя пакета, подпакета, модуля дает возможность
пользоваться в программе одноименными сущностями из разных пакетов.
Например, a.samename и b.samename. Кроме того точечная нотация дает своего
рода описание объекту. Например, выражения geometry.planimetry.House() или
geometry.stereometry.House() говорят, что в первом случае будет создан
двумерный объект-дом, во-втором – трехмерный. Это куда информативней,
чем просто House().
Однако в файле __init__.py в переменной __all__ можно перечислить,
какие модули будут импортироваться через from имя_пакета import *:
__all__ = ['planimetry', 'stereometry']
После этого можно делать так:
>>> from geometry import *
>>> b = stereometry.Ball(5)
>>> a = planimetry.Circle(5)
Выполнение модуля как скрипта
В Python обычный файл-скрипт, или файл-программа, не отличается от
файла-модуля почти ничем. Нет команд языка, которые бы "говорили", что вот
это – модуль, а это – скрипт. Отличие заключается лишь в том, что обычно
модули не содержат команды вызова функций и создания экземпляров в
основной ветке. В модуле обычно происходит только определение классов и
функций.
Однако, возможности языка позволяют в модули помещать код,
который будет выполняться, когда файл не импортируется, а сам передается
интерпретатору как самостоятельная программа. Выглядит это примерно так:
class A:
def __str__(self):
return "A"
if __name__ == "__main__":
print(A())
То, что находится в теле if, выполнится только в случае исполнения
файла как скрипта. Но не при импорте.
pl@pl-desk:~$ python3 test.py
A
Встроенный атрибут __name__, представляющий собой переменную,
есть у каждого файла. При импорте этой переменной присваивается имя
модуля:
>>> import math
>>> math.__name__
'math'
>>> planimetry.__name__
'geometry.planimetry'
Однако, когда файл исполняется как скрипт, значение __name__
становится равным строке "__main__". Это можно увидеть, если в код
поместить print(__name__) и выполнить файл как скрипт.
Таким образом, если __name__ равен «__main__», то выполняется код,
вложенный в тело условного оператора. Обычно сюда помещают код для
тестирования модуля в процессе разработки, а в готовый модуль – примеры,
как пользоваться определенными здесь сущностями.
