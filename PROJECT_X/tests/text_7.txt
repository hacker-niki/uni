ТЕМА 5. ВИРТУАЛЬНЫЕ ФУНКЦИИ
5.1. Взаимосвязь объектов производного и базовых классов
Объект производного класса хранит в памяти элементы базового класса.
На этапе выполнения программы возможно выделение объекта базового
класса из объекта производного класса а так же выделение объекта
производного класса по его объекту базового класса. Для этого используется
косвенное обращение к компонентам класса по указателям (ссылкам).
Указатели на объекты порожденных классов совместимы по типу с
указателями на объекты базового класса, поэтому указателю на объект
базового класса можно присваивать значение указателя на объект
производного класса без явного преобразования типа. Присваивание
указателю на объект производного класса значения указателя на объект
базового класса неявным образом запрещено (приведение типа должно быть
явным).
Пример 5.1. Организация доступа к методам посредством указателей.
class BCls
{
public:
void outp() {
cout << "Base class" << endl;
}
};
class PCls01 : public BCls
{
public:
void outp() {
cout << "PClass 01" << endl;
}
};
class PCls02 : public PCls01
{
public:
void outp() {
cout << "PClass 02" << endl;
}
};
int main()
{
PCls01 p01;
PCls02 p02;
BCls *ukb = &p01; ukb->outp(); // Выводит: Base class
ukb = &p02; ukb->outp(); // Выводит: Base class
PCls01 *ukp01 = &p02; ukp01->outp(); // Выводит: PClass 01
// ukp01 = ukb; // Ошибка: невозможно преобразовать " BCls *" в
"PCls01 *"
ukp01 = (PCls01*)ukb; ukp01->outp(); // Выводит: PClass 01
PCls02* ukp02 = (PCls02*)ukb; ukp02->outp(); // Выводит: PClass 02
ukp02 = (PCls02*)ukp01 ; ukp02->outp(); // Выводит: PClass
02
return 0;
}
Выводы:
1. Компилятор оценивает не содержимое, а тип указателя.
2. По адресу объекта производного класса можно непосредственно
получить адрес любого его объекта базового класса.
3. По адресу объекта базового класса, с использованием операции
приведения типа, можно получить адрес объекта производного класса
5.2. Виртуальные методы
Виртуальный метод — это метод класса, который может быть
переопределён в производных классах таким образом, что конкретная
реализация метода будет определяться во время выполнения программы.
Результат вызова виртуального метода с использованием указателя или
ссылки зависит не от типа указателя, а от типа объекта, на который указывает
этот указатель.
Класс, содержащий хотя бы одну виртуальную функцию, называется
полиморфным классом, а объект данного типа – полиморфным объектом.
При обращении к полиморфному объекту выбор метода осуществляется
на этапе выполнения в зависимости от того, с каким объектом ведется работа.
Для объявления витуального метода используется ключевое слово
virtual.
Если, например, в базовом классе BCls (см. пример 5.1.) метод outp будет
виртуальным:
virtual void outp()
то программа, в этом случае, будет выполняться следующим образом:
int main()
{
PCls01 p01;
PCls02 p02;
BCls *ukb = &p01; ukb->outp(); // Выводит: PClass 01
ukb = &p02; ukb->outp(); // Выводит: PClass 02
PCls01 *ukp01 = &p02; ukp01->outp(); // Выводит: PClass 02
ukp01 = (PCls01*)ukb; ukp01->outp(); // Выводит: PClass 02
PCls02* ukp02 = (PCls02*)ukb; ukp02->outp(); // Выводит: PClass 02
ukp02 = (PCls02*)ukp01 ; ukp02->outp(); // Выводит: PClass
02
return 0;
}
Вызов методов с помощью указателей или ссылок осуществляется
следующим образом:
• вызов невиртуального метода происходит в соответствии с типом
типом указателя или ссылки;
• вызов виртуального метода происходит в соответствии с типом
объекта, для которого он вызывается.
Пример 5.2. Совместное использование виртуальных и невиртуальных
функций.
class BCls {
public:
virtual void OutV() {
cout << " Base Virtual" << endl;
}
void OutN() {
cout << " Base Non-virtual" << endl;
}
};
class PCls : public BCls {
public:
virtual void OutV() {
cout << " Derived Virtual" << endl;
}
void OutN() {
cout << " Derived Non-virtual" << endl;
}
};
int main() {
PCls p;
BCls* ubase = &p;
PCls* uderived = &p;
ubase->OutN(); // Выводит: Base Non - virtual
uderived->OutN(); // Выводит: Derived Non - virtual
ubase->OutV(); // Выводит: Derived Virtual
uderived->OutV(); // Выводит: Derived Virtual
return 0;
}
Особенности виртуальных методов:
• если метод объявлен виртуальным, то он остается виртуальным во
всех производных классах (можно не использовать ключевое
слово virtual).
• статический методы не могут быть виртуальным;
• глобальные функции не могут быть виртуальными;
• виртуальные методы используются для обеспечения доступа к
объектам базового и виртуальных классов;
• как правило базовый класс определяет способ работы с объектами,
а производные классы предоставляют реализацию этого способа;
• виртуальные методы позволяют автоматизировать процесс
классификации объектов в неоднородной иерархии классов.
Пример 5.3. Применение виртуальных функций для классификации
объектов, помещаемых в контейнер:
#include <iostream>
using namespace std;
class BCls {
public:
virtual voidoutp () {
cout << "Base_class ";
}
};
class PCls01 : public BCls {
public:
void outp() {
cout << "Class_01 ";
}
};
class PCls02 : public PCls01 {
public:
void outp() {
cout << "Class_02 ";
}
};
void print_mas(BCls** a, int n) {
for (int i = 0; i < n; i++) {
a[i]-> outp();
}
}
void main() {
BCls* mas[3];
mas[0] = new BCls;
mas[1] = new PCls01;
mas[2] = new PCls02;
print_mas(mas, 3);
// Выводит: Base_class Class_01 Class_02
}
Базовые классы и их виртуальные методы могут быть созданы и
откомпилированы до определения производных классов.
Пример 5.4. Применение виртуальных функций.
#include <iostream>
using namespace std;
class BCls {
public:
int k;
BCls(int a) :k(a) {};
virtual void outp(BCls& x) {
cout << "BClass: k=" << x.k << endl;
}
void operator ++() {
++(this->k);
outp(*this);
}
};
class PCls : public BCls {
public:
PCls(int a) :BCls(a) {}
void outp(BCls& x) {
cout << "PClass: k=" << x.k << endl;
}
};
void main() {
PCls x(10);
BCls* y = &x;
y->outp(*y); // Вывод:PClass: k = 10
++(*y); // Вывод:PClass: k = 11
x.outp(x); // Вывод: PClass: k = 11
++x; // Вывод: PClass: k = 12
}
Для использования виртуальных методов обязательно совпадение
количества, типов и порядка следования параметров в методах базового и
производного классов.
Для подавления виртуального обращения к методу можно использовать
операцию разрешения области действий ("::"). Такое обращение позволяет
избежать потерь ресурсов на динамическое определение типа в задачах,
критичных к быстродействию.
Пример 5.4. Сформировать список товаров. Список должен содержать
информацию о наименовании и цене товара. Для акционных товаров должен
указываться размер скидки.
#include <iostream>
#include <string.h>
using namespace std;
class CProd
{
protected:
char* product;
double cena;
public:
CProd(const char* а, double b) : cena(b)
{
int n = strlen(а) + 1;
product = new char[n];
strcpy_s(product, n, а);
}
~CProd() { delete[]product; }
virtual void outp() {
cout << product << " : " << cena;
}
};
class CDsc : public CProd
{
int discount;
public:
CDsc(const char* a, double b, int c) : CProd(a, b), discount(c) {}
void outp() {
CProd::outp();
cout << " - " << discount << "%";
}
};
struct tstk {
tstk* a;
void* inf;
void add(tstk** sp, void* inform)
{
tstk* spt = new tstk;
spt->a = *sp;
spt->inf = inform;
*sp = spt;
}
};
class CShop {
tstk* tovars;
public:
CShop() : tovars(nullptr) {}
void operator += (void* x)
{
tovars->add(&tovars, x);
}
void operator()() {
cout << " List:" << endl;
for (tstk* x = tovars; x != nullptr; x = x->a)
{
((CProd*)x->inf)->outp();
cout << endl;
}
}
~CShop()
{
tstk* spt;
while (tovars != nullptr) {
spt = tovars;
tovars = tovars->a;
delete spt;
}
}
};
int main()
{
CShop tov;
tov += new CProd("Phone", 432.0);
tov += new CDsc("Table", 126.3, 10);
tov += new CDsc("TV", 692.3, 15);
tov += new CProd("Chair", 63.4);
tov();
return 0;
}
Результат выполненя программы:
List:
Chair : 63.4
TV : 692.3 - 15%
Table : 126.3 - 10%
Phone : 432
Виртуальные функции позволяют достичь гибкости привязки функций
к объектам за счет потерь памяти и быстродействия.
Недостатки использования виртуальных функций:
увеличение размера объекта из-за необходимости хранения указателя
на vtable;
обращение к виртуальным функциям через указатель, что фактически
означает отказ от возможности встраивания функции, что может
снижать быстродействие программы.
5.3. Раннее и позднее связывание.
В C++ полиморфизм реализуется двумя способами.
• ранним (статическим) связыванием – на стадии компиляции
посредством перегрузки функций и операторов;
• поздним (динамическим) связыванием − во время выполнения
программы посредством виртуальных функций.
Основой динамического полиморфизма является возможность
получения указателя на базовый класс, который в действительности указывает
не только на объект базового класса, но и на любой объект производного
класса.
Для каждого полиморфного типа данных компилятор создает таблицу
адресов виртуальных функций (VTABLE) и встраивает в каждый объект
скрытый указатель на нее (VPTR). Таблица виртуальных функций хранит в
себе адреса всех виртуальных методов класса и всех виртуальных методов
базового класса.
Количество таблиц виртуальных функций соответствует количеству
полиморфных классов. При вызове виртуальной функции из таблицы
извлекается адрес соответствующей функции и происходит ее вызов. Объект
класса содержит указатель на соответствующую таблицу.
Пример 5.6. Использование виртуальных методов.
#include <iostream>
using namespace std;
class BCls
{
public:
BCls() { cout << "B : Constr" << endl; }
virtual ~BCls() { cout << "B : Desrt" << endl; }
virtual void M1() { cout << "B : M1" << endl; }
virtual void M2() { cout << "B : M2" << endl; }
};
class PCls : public BCls
{
public:
PCls() { cout << "P : Constr" << endl; }
~PCls() { cout << "P : Desrt" << endl; }
virtual void M2() { cout << "P : M2" << endl; }
virtual void M3() { cout << "P : M3" << endl; }
};
int main()
{
BCls *pBCls = new PCls; // Выводит: B : Constr P : Constr
pBCls->M1(); // Выводит: B : M1
pBCls->M2(); // Выводит: P : M2
// pBCls->M3(); // Ошибка: M3: не является членом " BCls"
delete pBCls; // Выводит: P : Desrt B : Desrt
return 0;
}
В программе имеется две таблицы виртуальных функций. :
BCls
void *vptr
0 BCls : ~ BCls
1 BCls : M1
2 BCls : M2
PCls
void *vptr
0 BCls : ~ BCls
1 BCls : M1
2 PCls : M2
3 PCls : ~ PCls
4 PCls : M3
Для каждого класса создается таблица виртуальных методов. Каждому
методу присваивается индекс (в порядке объявления методов), по которому
определяется адрес этого метода в таблице (например, *vptr +1). Виртуальная
таблица производного класса строится на основе виртуальной таблицы
базового класса. Если виртуальный метод переопределен в производном
классе, то изменяется указатель этот метод таблице производного класса. Если
в производном классе появляется новый виртуальный метод, то виртуальная
таблица производного класса расширяется.
В программе объявлен указатель на базовый класса BCls, которому
присваивается адрес объекта производного класса PCls. Вначале вызывается
конструктор базового класса, который создает таблицу виртуальных функций
и получает указатель на нее. После этого вызывается конструктор
производного класса, который перезаписывает виртуальную таблицу. При
вызове методов M1 и М2 компилятор через указатель VPTR получает
фактический адрес метода. Для этого происходит обращение к методу по его
номеру (М1 – *vptr+1, М2 − *vptr+2). Так как таблица виртуальных методов
базового класса содержит только два метода, то при обращении к третьему
методу (обращение *vptr+4) возникает ошибка.
Пример 5.7. Определение размера виртуальной и невиртуалной
функций.
class ClsNV {
public:
void f() {}
};
class ClsV1 {
public:
virtual void f() {}
};
class ClsV2 {
public:
virtual void f1() {}
virtual void f2() {}
virtual void f3() {}
virtual void f4() {}
virtual void f5() {}
virtual void f6() {}
virtual void f7() {}
virtual void f8() {}
virtual void f9() {}
};
void main() {
cout << sizeof(ClsNV) << endl; // Выводит: 1
cout << sizeof(ClsV1) << endl; // Выводит: 8
cout << sizeof(ClsV2) << endl; // Выводит: 8
}
Размер полиморфного класса не увеличивается при увеличении
количества виртуальных функций, т.к. хранит только указатель на таблицу
VPTR, а не саму таблицу.
5.4. Виртуальные деструкторы
В отличие от конструкторов, деструкторы могут быть виртуальными.
Пример 5.8. Работа деструктора в объекте производного класса (для
краткости выделение и освобождение памяти в коде опущено).
#include <iostream>
using namespace std;
class BCls
{
double *x;
public:
~BCls() { cout << "BCls - Delete x" << endl; }
};
class PCls : public BCls
{
char *z;
public:
~PCls() { cout << "PCls - Delete z" << endl; }
};
class VBCls
{
double* x;
public:
virtual ~VBCls() { cout << "VBCls - Delete x" << endl; }
};
class VPCls : public VBCls
{
char* z;
public:
~VPCls() { cout << "VPCls - Delete z" << endl; }
};
void main()
{
BCls *uk1 = new PCls;
delete uk1;
// Выводит: BCls - Delete x
VBCls* uk2 = new VPCls;
delete uk2;
// Выводит: VPCls - Delete z
// Выводит: VBCls - Delete x
}
При удалении объекта вызывается деструктор класса соответствующего
указателю на объект.
При удалении объекта класса PCls доступ к которому осуществлялся
через указатель на базовый BCls вызывается только деструктор базового
класса, следовательно, происходит утечка памяти.
При удалении объекта класса VPCls доступ к которому осущетсвлялся
через указатель на базовый VBCls вызывается как виртуальный деструктор
базового класса, так и дестуктор производного класса.
Особенности:
• деструктор, генерируемый системой по умолчанию яляется
невиртуальным;
• если деструктор базового класса является виртуальным, то
деструкторы производных классов так же будут виртуальными.
5.5. Абстрактные классы и чисто виртуальные методы
Для запрета использования виртуальных функций базового класса
используются чисто (строго) виртуальные методы:
virtual тип_результата <имя_метода>(<список_параметров>) = 0;
Любой класс, содержащий хотя бы один чисто виртуальный метод,
называется абстрактным. Создание объектов абстрактного класса запрещено.
Абстрактный класс предназначен для использования в качестве базового
для наследования невиртуальных элементов в производных классах.
Чисто виртуальные функции обязательно должны переопределяться в
производном классе. Если в производном классе отсутствует переопределение
чисто виртуального метода, то он так же становится абстрактным!
Пример 5.9. Работа абстрактными классами.
class BACls
{
public:
virtual void print() = 0;
};
class PCls01 : public BACls
{
public:
virtual void print() { cout << "PCls01" << endl; }
};
class PCls02 : public BACls
{
public:
virtual void printx() { cout << "PCls02" << endl; }
};
class PCls03 : public PCls02
{
public:
virtual void print() { cout << "PCls03" << endl; }
};
void main() {
// BACls b;
// Ошибка: невозможно создать экземпляр абстрактного класса
BACls * qb;
PCls01 p1;
qb = &p1;
qb->print(); // Выводит: PCls01
// PCls02 p2;
// Ошибка: невозможно создать экземпляр абстрактного класса
PCls03 p3;
qb = &p3;
qb->print(); // Выводит: PCls03
}
Особенности абстрактных классов:
• нельзя объявлять объекты абстрактного класса;
• нельзя использовать для полей;
• нельзя использовать имя абстрактного класса в качестве типа
аргумента функции;
• имя абстрактного класса не может использоваться в качестве типа
возвращаемого значения функции;
• запрещено явное преобразование типа объекта к типу
абстрактного класса;
• разрешено использование указателя или ссылки на абстрактный
класс.
При создании производного класса возможны ошибки в
переопределении абстактного метода (ошибка в написании метода, отсутствие
спецификатора const, неправильный тип параметра). В этом случае
абстрактный метод остается непереопределенным, а производный класс
становится абстрактным.
Для преодоления таких ошибок введен спецификатор override, который
указывает, что метод является переопределением виртуального метода в
базовом классе. Если переопределение неверное, то на этапе компиляции
возникают ошибки.
Для запрета переопределения в производном классе описанного в
родительском классе виртуального метода от должен содержать спецификатор
final.
Пример 5.10. Написать абстактный и производные классы для
вычисления площади и периметра фигуры.
class BACls
{
public:
virtual double S() = 0; // Площадь
virtual double P() = 0; // Периметр
virtual void name() = 0;
virtual void outp() final
{
name();
cout << " square = " << S() << " perimeter = " << P() << endl;
}
};
class Rect : public BACls
{
private:
double w;
double h;
public:
Rect(double a, double b) : w(a), h(b)
{ }
// double S(int x) override // Ошибка: метод со спецификатором
// { } // "override" не переопределяет какие либо методы базового
класса
double S() override
{
return w * h;
}
double P() override
{
return 2 * (w + h);
}
void name() override
{
cout << "Rectangle";
}
// void outp() {}
// Ошибка: функцию, объявленную как " final", нельзя
переопределить
};
class Crcl : public BACls
{
private:
double r;
public:
Crcl(double a) : r(a)
{ }
double S() override
{
return 3.14* r* r;
}
double P() override
{
return 2 * 3.14* r;
}
void name() override
{
cout << "Circle";
}
};
int main()
{
Rect rectangle(3, 4);
rectangle.outp(); // Выводит: Rectangle square = 12 perimeter = 14
Crcl circle(1);
circle.outp(); // Выводит: Circle square = 3.14 perimeter = 6.28
return 0;
}
