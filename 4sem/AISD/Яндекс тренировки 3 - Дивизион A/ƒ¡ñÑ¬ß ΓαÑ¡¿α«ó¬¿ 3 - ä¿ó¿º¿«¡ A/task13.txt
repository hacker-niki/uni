def precedence(op):
    if op == '!':
        return 3
    if op == '&':
        return 2
    if op == '|':
        return 1
    if op == '^':
        return 1
    return 0

def apply_op(a, b, op):
    if op == '&':
        return a & b
    if op == '|':
        return a | b
    if op == '^':
        return a ^ b

def apply_not(a):
    return not a

def evaluate(expression):
    values = []
    ops = []
    i = 0
    
    while i < len(expression):
        if expression[i] == ' ':
            i += 1
            continue
        
        if expression[i] == '0':
            values.append(0)
            i += 1
        
        elif expression[i] == '1':
            values.append(1)
            i += 1
        
        elif expression[i] == '(':
            ops.append(expression[i])
            i += 1
        
        elif expression[i] == ')':
            while len(ops) != 0 and ops[-1] != '(':
                op = ops.pop()
                if op == '!':
                    val = values.pop()
                    values.append(apply_not(val))
                else:
                    val2 = values.pop()
                    val1 = values.pop()
                    values.append(apply_op(val1, val2, op))
            ops.pop()
            i += 1
        
        elif expression[i] in "!&|^":
            while (len(ops) != 0 and precedence(ops[-1]) >= precedence(expression[i])):
                op = ops.pop()
                if op == '!':
                    val = values.pop()
                    values.append(apply_not(val))
                else:
                    val2 = values.pop()
                    val1 = values.pop()
                    values.append(apply_op(val1, val2, op))
            ops.append(expression[i])
            i += 1
    
    while len(ops) != 0:
        op = ops.pop()
        if op == '!':
            val = values.pop()
            values.append(apply_not(val))
        else:
            val2 = values.pop()
            val1 = values.pop()
            values.append(apply_op(val1, val2, op))
    
    return values[-1]

expression = input()
print(int(evaluate(expression)))